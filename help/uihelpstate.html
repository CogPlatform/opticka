<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>uihelpstate</title>
  <style>
  html {font-family: Hoefler Text, Palatino, Georgia, serif;
    color: #1a1a1a;
    background-color: #fdfdfd;}

  body {margin: 0 auto;
    max-width: 40em;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 5px;
    padding-bottom: 5px;
    hyphens: auto;
    overflow-wrap: break-word;
    text-rendering: optimizeLegibility;
    font-kerning: normal;
  }

  @media (max-width: 600px) {body {font-size: 0.9em;
    padding: 1em;}
    h1 {font-size: 1.8em;}
  }

  @media print {body {background-color: transparent;
    color: black;
    font-size: 12pt;}
    p, h2, h3 {	orphans: 3;
    widows: 3;}
    h2, h3, h4 {	page-break-after: avoid;}
  }

  header {display: none;}
  kbd {margin: 0px 0.1em;
    padding: 0.1em 0.6em;
    border-radius: 3px;
    border: 1px solid rgb(204, 204, 204);
    color: rgb(51, 51, 51);
    line-height: 1.4;
    font-family: Menlo, monospace;
    font-size: 11px;
    display: inline-block;
    box-shadow: 0px 1px 0px rgba(0,0,0,0.3);
    background-color: rgb(247, 247, 247);
    text-shadow: 0 1px 0 #fff;
  }
  kbd:hover {box-shadow: 0 1px 0 0.5px;}
  p {font-size: 18px;margin: 0.8em 0;line-height: 1.5;}
  a {color: #1a1a1a;}
  a:visited {color: #1a1a1a;}
  img {max-width: 100%;}
  h1, h2, h3, h4, h5, h6 {margin-top: 1.4em;}
  h5, h6 {font-size: 1em;
  font-style: italic;}
  h6 {font-weight: normal;}
  ol, ul {font-size: 18px;
    line-height: 1.2em;
    padding-left: 1.7em;
    margin-top: 1em;}
  li > ol, li > ul {margin-top: 0;}
  blockquote {margin: 1em 0 1em 1.7em;
    padding-left: 1em;
    border-left: 2px solid #e6e6e6;
    color: #606060;
    font-style: italic;}
  code {font-family: Fira Code, Menlo, Consolas, monospace;
    font-size: 14px;
    margin: 0;
    background-color: #F0F0F0;
    color:rgb(145, 16, 42);
  }
  pre {margin: 1em 0;
    overflow: auto;
  }
  pre code {padding: 0;
    overflow: visible;
    overflow-wrap: normal;
    background-color:transparent;
    color: black;
  }
  pre.smaller code {font-size: 60% !important; line-height: .75rem !important;}
  .sourceCode {background-color: transparent;
    overflow: visible;
  }
  hr {background-color: #1a1a1a;
    border: none;
    height: 1px;
    margin: 1em 0;
  }
  table {margin: 1em 0;
    border-collapse: collapse;
    width: 100%;
    overflow-x: auto;
    display: block;
    font-variant-numeric: lining-nums tabular-nums;
  }
  table caption {margin-bottom: 0.75em;}
  tbody {margin-top: 0.5em;
    border-top: 1px solid #1a1a1a;
    border-bottom: 1px solid #1a1a1a;
  }
  th {border-top: 1px solid #1a1a1a;
    padding: 0.25em 0.5em 0.25em 0.5em;
  }
  td {padding: 0.125em 0.5em 0.25em 0.5em;}
  header {margin-bottom: 4em;
    text-align: center;
  }
  #TOC li {list-style: none;}
  #TOC ul {padding-left: 1.3em;}
  #TOC > ul {padding-left: 0;}
  #TOC a:not(:hover) {text-decoration: none;}
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
  pre > code.sourceCode { white-space: pre; position: relative;}
  pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
  pre > code.sourceCode > span:empty { height: 1.2em; }
  .sourceCode { overflow: visible; }
  code.sourceCode > span { color: inherit; text-decoration: inherit; }
  div.sourceCode { margin: 2em 0; }
  pre.sourceCode { margin: 0; }
  @media screen {
  div.sourceCode { overflow: auto; background-color: #F0F0F0;}
  }
  @media print {
  pre > code.sourceCode { white-space: pre-wrap;}
  pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
  }
  pre.numberSource code
    { counter-reset: source-line 0; }
  pre.numberSource code > span
    { position: relative; left: -4em; counter-increment: source-line; }
  pre.numberSource code > span > a:first-child::before
    { content: counter(source-line);
      position: relative; left: -1em; text-align: right; vertical-align: baseline;
      border: none; display: inline-block;
      -webkit-touch-callout: none; -webkit-user-select: none;
      -khtml-user-select: none; -moz-user-select: none;
      -ms-user-select: none; user-select: none;
      padding: 0 4px; width: 4em;
      color: #aaaaaa;
    }
  pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
  @media screen {
  pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
  }
  code span.al { color: #ff0000; font-weight: bold; } /* Alert */
  code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
  code span.at { color: #7d9029; } /* Attribute */
  code span.bn { color: #40a070; } /* BaseN */
  code span.bu { color: #008000; } /* BuiltIn */
  code span.cf { color: #0044a3; font-weight: bold; } /* ControlFlow */
  code span.ch { color: #4070a0; } /* Char */
  code span.cn { color: #880000; } /* Constant */
  code span.co { color: #779097; font-style: italic; } /* Comment */
  code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
  code span.do { color: #ba2121; font-style: italic; } /* Documentation */
  code span.dt { color: #902000; } /* DataType */
  code span.dv { color: #40a070; } /* DecVal */
  code span.er { color: #ff0000; font-weight: bold; } /* Error */
  code span.fl { color: #40a070; } /* Float */
  code span.fu { color: #06287e; } /* Function */
  code span.im { color: #008000; font-weight: bold; } /* Import */
  code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  code span.kw { color: #00338a; font-weight: bold; } /* Keyword */
  code span.op { color: #666666; } /* Operator */
  code span.ot { color: #007020; } /* Other */
  code span.pp { color: #bc7a00; } /* Preprocessor */
  code span.sc { color: #4070a0; } /* SpecialChar */
  code span.ss { color: #bb6688; } /* SpecialString */
  code span.st { color: #4070a0; } /* String */
  code span.va { color: #201f45; } /* Variable */
  code span.vs { color: #4070a0; } /* VerbatimString */
  code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Contents</h2>

</nav>
<h1 id="state-machine-info-files">State Machine Info Files</h1>
<p>Any experiment can be thought of as a series of states (delay,
fixate, stimulus, reward, timeout e.t.c.) and transitions between these
states. State Machines are a widely used control system for these types
of scenarios. The important definition of a state machine is:</p>
<ol type="1">
<li>The state machine must be in exactly one of a finite number of
states at any given time. States usually run for a defined amount of
time.</li>
<li>The state machine can also change from one state to another in
response to some input; the change from one state to another is called a
<strong>transition</strong> (<code>transitionFcn</code>). A function
controls the transition, returning a different state name that forces a
transition to this new state.</li>
<li>Functions can run when we <strong>enter</strong>
(<code>enterFcn</code>), are <strong>within</strong>
(<code>withinFcn</code>), or <strong>exit</strong>
(<code>exitFcn</code>) a state.</li>
</ol>
<p>Opticka defines all of this in a <code>StateInfo.m</code> file that
specifies function arrays and then assigns them to a state list. The
Opticka GUI visualises the state table and shows each function
array.</p>
<p>For example this cell array identifies two functions which draw and
animate our <code>stims</code> stimulus object:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>{ <span class="op">@</span>()<span class="va">draw</span>(<span class="va">stims</span>)<span class="op">;</span> <span class="op">@</span>()<span class="va">animate</span>(<span class="va">stims</span>)<span class="op">;</span> }</span></code></pre></div>
<p>See details below for the core functions that can run during the
state machine traversal. You can additionally write your own functions
and store them in a <a href="uihelpfunctions.html">userFunctions.m</a>
class file.</p>
<p>For example the <code>DefaultStateInfo.m</code> file defines several
experiment states (<em>prefix</em>, <em>fixate</em>, <em>stimulus</em>,
<em>incorrect</em>, <em>breakfix</em>, <em>correct</em>,
<em>timeout</em>) and how the task switches between them (either with a
timer or transitioned using an eyetracker):</p>
<pre class="smaller"><code>                                                       ┌───────────────────┐
                                                       │      prefix       │
  ┌──────────────────────────────────────────────────▶ │    hide(stims)    │ ◀┐
  │                                                    └───────────────────┘  │
  │                                                      │                    │
  │                                                      ▼                    │
  │                         ┌───────────┐  inFixFcn:   ┌───────────────────┐  │
  │                         │ incorrect │  incorrect   │      fixate       │  │
  │                         │           │ ◀─────────── │   show(stims,2)   │  │
  │ reward!                 └───────────┘              └───────────────────┘  │
  │                           │                          │ inFixFcn:          │
  │                           │                          │ stimulus           │
  │                           │                          ▼                    │
┌─────────┐  maintainFixFcn:  │                        ┌───────────────────┐  │
│ correct │  correct          │                        │     stimulus      │  │
│         │ ◀─────────────────┼─────────────────────── │ show(stims,[1 2]) │  │
└─────────┘                   │                        └───────────────────┘  │
                              │                          │ maintainFixFcn:    │
                              │                          │ breakfix           │
                              │                          ▼                    │
                              │                        ┌───────────────────┐  │
                              │                        │     breakfix      │  │
                              │                        └───────────────────┘  │
                              │                          │                    │
                              │                          ▼                    │
                              │                        ┌───────────────────┐  │
                              │                        │      timeout      │  │
                              └──────────────────────▶ │      tS.tOut      │ ─┘
                                                       └───────────────────┘</code></pre>
<p>State info files, being plain <code>.m</code> files, should be edited
in the MATLAB editor (the GUI has an edit button that opens the file in
the editor for you).</p>
<hr />
<h1 id="useful-task-methods">Useful Task Methods</h1>
<p>The state machine (<code>stateMachine</code> class) defines states
and the connections between them. The state machine can run cell arrays
of methods (<code>@()</code> anonymous functions) when states are
entered (run once), within (repeated on every screen redraw) and exited
(run once). In addition there are ways to transition <em>out</em> of a
state if some condition is met. For example if we are in a
<code>[STATE 1]</code> state and the eyetracker tells us the subject has
fixated for the correct time, then transition functions can jump us to
another state to e.g. show a stimulus.</p>
<pre class="smaller"><code>╔════════════════════════════════════════════════════════════════════════════════════════════════╗
║                  ┌─────────┐                                       ┌─────────┐                 ║
║                  │ STATE 1 │                                       │ STATE 2 │                 ║
║       ┌──────────┴─────────┴───────────┐                ┌──────────┴─────────┴──────────┐      ║
║  ┌────┴────┐      ┌────────┐      ┌────┴───┐       ┌────┴────┐      ┌────────┐     ┌────┴───┐  ║
╚═▶│  ENTER  │─────▶│ WITHIN │─────▶│  EXIT  │══════▶│  ENTER  │─────▶│ WITHIN │────▶│  EXIT  │══╣
   └────┬────┘      └────────┘      └────┬───┘       └────┬────┘      └────────┘     └────┬───┘  ║
        │          ┌──────────┐          │                │          ┌──────────┐         │      ║
        └──────────┤TRANSITION├──────────┘                └──────────┤TRANSITION├─────────┘      ║
                   └─────╦────┘                                      └──────────┘                ║
                         ║                  ┌─────────┐                                          ║
                         ║                  │ STATE 3 │                                          ║
                         ║       ┌──────────┴─────────┴───────────┐                              ║
                         ║  ┌────┴────┐      ┌────────┐      ┌────┴───┐                          ║
                         ╚═▶│  ENTER  │─────▶│ WITHIN │─────▶│  EXIT  │══════════════════════════╝
                            └────┬────┘      └────────┘      └────┬───┘
                                 │          ┌──────────┐          │
                                 └──────────┤TRANSITION├──────────┘
                                            └──────────┘</code></pre>
<p>These various methods control the logic and flow of experiments. This
document lists the most important ones used in flexible behavioural task
design. It is better for these methods to evaluate properties
(properties are the variables managed by the class object). Because of
this we choose to create methods that alter the properties of each
class. For example, <code>show(stims)</code> is a method that allows the
stimulus manager to show all stimuli in the list; it does this by
setting each stimulus’ <code>isVisible</code> property to
<code>true</code>. <code>hide(stims)</code> hides all stimuli bby
setting <code>isVisible</code> property to <code>false</code>, or you
could just hide the 3rd stimulus in the list:
<code>hide(stims, 3)</code>.</p>
<p>For those unfamiliar with object-oriented design, a <em>CLASS</em>
(e.g. <code>stateMachine</code>) is initiated as an <em>OBJECT</em>
variable (named <code>sM</code> during the experiment run, it is an
<em>instance</em> of the class). <strong>ALL</strong> Opticka classes
are <a
href="https://www.mathworks.com/help/matlab/handle-classes.html"><strong>handle
classes</strong></a>; this means if we assign <code>sM2 = sM</code> —
<strong>both</strong> of these named instances point to the
<strong>same</strong> object.</p>
<p>As experiments are run <strong><em>inside</em></strong> the
<code>runExperiment.runTask()</code> method, this class refers to
<em>itself</em> as <code>me</code>, so methods that <em>belong</em> to
<code>runExperiment</code> can be called by using
<code>me.myMethod()</code> or <code>myMethod(me)</code> (both forms are
equivalent to MATLAB). Other important object instances, for example the
<code>screenManager</code> class is called via <code>s</code>, so to
call the method <code>drawSpot</code> from our
<code>screenManager</code> instance <code>s</code>, we can use
<code>drawSpot(s)</code> (or <code>s.drawSpot()</code>). You will see
below the object names that are available as we run the experiment from
<code>runExperiment</code>. The <code>runExperiment</code> object
<code>me</code> keeps most of the objects as properties: so
<code>s</code> is actually also stored in the property
<code>me.screen</code>, <code>sM</code> is stored in the property
<code>me.stateMachine</code> etc.</p>
<h3 id="similar-named-methods">Similar named methods?</h3>
<p>In some cases <code>runExperiment</code> manages an object with
similar named methods. For example
<code>runExperiment.updateTask()</code> will manage the call to
<code>taskSequence.updateTask()</code>, this is often so that
runExperiment can <em>co-ordinate</em> among objects and maintain state
(when information needs to be shared between objects). If this is not
required then we just call the object methods directly,
e.g. <code>drawBackground(s)</code> uses <code>screenManager</code> to
run the PTB Screen() functions to draw a background colour (the property
<code>s.backgroundColour</code>) to the screen. See
<code>DefaultStateInfo.m</code> and other CoreProtocols state info files
for examples of their use…</p>
<h3 id="user-functions-files">User Functions Files</h3>
<p>If you want to write your own functions to be called by the
<code>stateMachine</code>, then you can add them to a
<code>userFunctions.m</code> file, <a href="uihelpfunctions.html">see
the docs</a> for details.</p>
<hr />
<h1 id="list-of-methods">List of Methods</h1>
<p>We highlight the main classes and methods that are most useful when
building your paradigm:</p>
<h2 id="runexperiment-me-in-the-state-file">runExperiment (“me” in the
state file)</h2>
<p>The principal class object that ‘runs’ the experiment.</p>
<ul>
<li><p><code>enableFlip(me)</code> || <code>disableFlip(me)</code><br />
Enable or disable the PTB screen flip during the update loop.</p></li>
<li><p><code>needEyeSample(me, value)</code><br />
On each frame we can check the current eye position (called via
<code>getSample(eT)</code>of the eye tracker object). This method allows
us to turn this ON (<code>true</code>) or OFF
(<code>false</code>).</p></li>
<li><p><code>var = getTaskIndex(me)</code><br />
It returns the current trial’s variable number by calling
<code>task.outIndex(task.totalRuns)</code>. A trial variable number is
unique to a particular task condition (see the <code>taskSequence</code>
class which builds these randomised sequences).</p></li>
<li><p><code>updateFixationTarget(me, useTask, varargin)</code> ||
<code>updateExclusionZones(me, useTask, radius)</code><br />
To manage several stimuli together, we use the <code>metaStimulus</code>
class (object name: <code>stims</code>). If you set the
<code>metaStimulus.fixationChoice</code> parameter you can specify from
which stimuli to collect the X and Y positions from.
<code>updateFixationTarget(me)</code> (calling
<code>getFixationPositions(stims)</code> internally) iterates through
each selected stimulus and returns the X and Y positions assigned to
<code>me.lastXPosition</code> and <code>me.lastYPosition</code>. Having
these values we can now assign them using
<code>updateFixationValues(eT)</code>.
<code>updateExclusionZones()</code> does the same using
<code>metaStimulus.exclusionChoice</code> to recover the X and Y
positions to set up exclusion zones around specified stimuli.</p></li>
<li><p><code>updateConditionalFixationTarget(me, stimulus, variable, value, varargin)</code><br />
Say you have 4 stimuli each with a different angle changed on every
trial by the task object, and want the stimulus matching
<code>angle = 90</code> to be used as the fixation target. This method
finds which stimulus is set to a particular variable value and assigns
the fixation target X and Y position to that stimulus.</p></li>
<li><p><code>updateNextState(me, type)</code><br />
It is possible to force the stateMachine to jump to a tranisition to a
named state by editing stateMachine.tempNextState. This method takes the
current taskSequence trialVar or blockVar and sets the next state name
to the value contained for the current trial. So for example you can set
trialVar to <code>{'stimulus','catch'}</code> which randomises each
trial with either ‘stimulus’ or ‘catch’, then use
<code>@()updateNextState(me,'trial')</code> to choose this value as the
temporary next state name.</p></li>
</ul>
<hr />
<h2 id="task-sequence-manager-task-in-the-state-file">Task sequence
manager (“task” in the state file)</h2>
<ul>
<li><p><code>updateTask(me, thisResponse, runTime, info)</code><br />
You can update the task by calling this method.
<code>thisResponse</code> is the response to the trial (correct,
incorrect etc. as you’ve defined), the runTime is the current time, and
info is any other information (often the info given by
<code>runExperiment</code>). In general, it is better to call
<code>runExperiment.updateTask</code> which generates the
<code>info</code> for you using the current information from the
eyetracker and stimuli.</p></li>
<li><p><code>resetRun(task)</code><br />
If the subject fails to respond correctly, this method randomises the
next trial within the block, minimising the possibility the subject just
guesses. If you are at the last trial of a block then this will not do
anything.</p></li>
<li><p><code>rewindRun(task)</code><br />
This method rewinds back one trial, allowing you to replay that run
again.</p></li>
</ul>
<hr />
<h2 id="the-eye-tracker-et-in-the-state-file">The eye tracker (“eT” in
the state file)</h2>
<ul>
<li><p><code>updateFixationValues(eT, X, Y, inittime, fixtime, radius, strict)</code><br />
This method allows us to update the <code>eT.fixation</code> structure
property; we pass in the various parameters that define the fixation
window:</p>
<ul>
<li><code>X</code> = X position in degrees relative to screen centre [0,
0]. <code>+X</code> is to the left.</li>
<li><code>Y</code> = Y position in degrees relative to screen centre [0,
0]. <code>+Y</code> is upwards.</li>
<li><code>inittime</code> = How long the subject is allowed to search
before their eye enters the window.</li>
<li><code>fixtime</code> = How long the subject must keep their eyes
within the fixation window.</li>
<li><code>radius</code> = if this is a single value, this is the
circular radius around <code>X,Y</code>. If it is 2 values it defines
the width × height of rectangle around <code>X,Y</code>.</li>
<li><code>strict</code> = if strict is <code>true</code> then do not
allow a subject to leave a fixation window once they enter. If
<code>false</code> then a subject may enter, leave and re-enter without
failure (but must still keep the eye inside the window for the required
time).</li>
</ul>
<p>Note that this command implicitly calls
<code>resetFixation(eT)</code> as any previous fixation becomes
invalid.</p></li>
<li><p><code>resetFixation(eT, removeHistory)</code> ||
<code>resetFixationHistory(eT)</code> ||
<code>resetFixationTime(eT)</code> ||
<code>resetExclusionZone(eT)</code> || <code>resetFixInit(eT)</code></p>
<ul>
<li><code>resetFixation</code> resets all fixation counters that track
how long a fixation was held for. Pass <code>removeHistory</code> ==
true also calls <code>resetFixationHistory(eT)</code> to remove the
temporary log of recent eye positions (this is useful for online
plotting of the recent eye position for the last trial etc.)</li>
<li><code>resetFixationTime</code> only reset the fixation window
timers.</li>
<li><code>resetExclusionZone</code>: resets (removes) the exclusion
zones.</li>
<li><code>resetFixInit</code>: <em>fixInit</em> is a timer that stops a
saccade <em>away</em> from a screen position to occur too quickly
(default = 100ms). This method removes this test.</li>
</ul></li>
<li><p><code>resetOffset(eT)</code><br />
Reset the drift offset back to <code>X = 0; Y = 0</code> — see
<code>driftOffset(eT)</code> for the method that sets this
value.</p></li>
<li><p><code>updateFixationValues(eT,x,y,inittime,fixtime,radius,strict)</code>
|| <code>updateExclusionZones(eT,x,y,radius)</code><br />
These methods allows you to change any of the parameters of the fixation
window[s] or the exclusion zone[s]. The fixation window[s] can be
circular or square, the exclusion zone[a] are square.</p></li>
<li><p><code>getSample(eT)</code><br />
</p>
<p>This simply gets the current X, Y, pupil data from the eyetracker (or
if in dummy mode from the mouse position). This is saved in
<code>eT.x</code> <code>eT.y</code> <code>eT.pupil</code> and logged to
<code>eT.xAll</code> <code>eT.yAll</code> <code>eT.pupilAll</code>.
NORMALLY you do not need to call this is it is called by runExperiment
for you on every frame, depending on whether
<code>needEyeSample(me)</code> method was set to <code>true</code> or
<code>false</code>.</p></li>
</ul>
<hr />
<h2 id="metastimulus-stims-in-the-state-file">metaStimulus (“stims” in
the state file)</h2>
<p>This class manages groups of stimuli as a single object. Each
stimulus can be shown or hidden and metaStimulus can also managed
masking stimuli if needed.</p>
<ul>
<li><p><code>show(stims, [index])</code><br />
Show enables a particular stimulus to be drawn to the screen. Without
<code>[index]</code> all stimuli are shown. You can specify sets of
stimuli, e.g. <code>show(stims, [2 4])</code> to show the second and
fourth stimuli.</p></li>
<li><p><code>hide(stims, [index])</code><br />
The reverse of <code>show()</code>. if <code>index</code> is empty, hide
all stimuli. You can specify sets of stimuli,
e.g. <code>hide(stims, [2 4])</code> to hide the second and fourth
stimuli.</p></li>
<li><p><code>showSet(stims, n)</code><br />
<code>stims.stimulusSets</code> is an array of ‘sets’ of stimuli, for
example <code>{3, [1 3], [1 2 3]}</code> and calling
e.g. <code>showSet(stims, 3)</code>, would first hide all the stims
(<code>hide(stims)</code>), then run <code>show(stims, [1 2 3])</code>.
This just makes it a bit easy to manage pre-specified stimulus
sets.</p></li>
<li><p><code>edit(stims,stimulus,variable,value)</code><br />
Allows you to modify any parameter of a stimulus during the trial,
e.g. <code>edit(stims,3,'sizeOut',2);</code> sets the size of stimulus 3
to 2°.</p></li>
<li><p><code>draw(stims)</code><br />
Calls the <code>draw()</code> method on each of the managed stimuli.
Note if you’ve used <code>show()</code> or <code>hide()</code> or
<code>showSet()</code> then some stmuli may not be displayed. This
should be called on every frame update, by setting it to run in the
<code>withinFcn</code> array.</p></li>
<li><p><code>animate(stims)</code><br />
Calls the <code>animate()</code> method for each stimulus, which runs
any required per-frame updates (for drifting gratings, moving dots,
flashing spots etc.). This should be called after <code>draw()</code>
for every frame update within a <code>withinFcn</code> cell
array.</p></li>
<li><p><code>update(stims)</code><br />
For trial based designs, we may change a variable (like size, or spatial
frequency), and <code>update()</code> ensures the stimulus recalculate
for this new variable. This is usually run in a correct/incorrect
<code>exitFcn</code> block after first calling
<code>updateVariables(me)</code>. Note some variables (like phase for
gratings) do not require an <code>update()</code> but are applied
immediately; however this depends on their implementation in PTB.
<code>update</code> can cost a bit of time depending on the stiulus
type, so it is not recommended to call it on every frame, but only when
necessary.</p></li>
</ul>
<hr />
<h2 id="screen-manager-s-in-the-state-file">Screen Manager (“s” in the
state file)</h2>
<ul>
<li><code>drawBackground(s)</code><br />
Draws the s.backgroundColour to screen.</li>
</ul>
<h1 id="faq">FAQ</h1>
<hr />
<ul>
<li><strong>Question:</strong> My subject gave an incorrect answer, but
I don’t want to keep repeating the same stimulus.</li>
<li><strong>Answer:</strong> Use resetRun(task) which chooses another
run in the same block and swaps it. Note if we are on the last trial of
a block, we cannot swap as we want to preserve repeats per block.</li>
</ul>
<hr />
<ul>
<li><strong>Question:</strong> I want to randomise some values of the
stimuli but not include them as an indepedant variable.</li>
<li><strong>Answer:</strong> The metaStimulus object contains a
stimulusTable which allows you to make changes to stimuli without them
added to the trial structure. This is useful during training, or if you
need randomisation tangential to the task. As an example, in Chen et
al., 2020 Science their Saccade-to-Phosphene task randomises the size
and colour of the target but this is not used as a task variable. In
this case set stimulusTable and then call
<code>@()randomise(stims);</code> in the state machine functions
(normally just before you call <code>@()update(stims);</code>). This
will give randomised size and colour without adding any independant
variables.</li>
</ul>
<hr />
<h1 id="definitions">Definitions</h1>
<dl>
<dt>Class</dt>
<dd>
A class is a way to combine a set of related variables (properties) and
functions (methods) in a unified object. In MATLAB we use
<code>classdef</code> to build a class.
</dd>
<dt>Object</dt>
<dd>
A class is a kind of thing, but when we want to use that thing, we
<em>instantiate</em> it into a ‘real’ object. So calling
<code>s = screenManager</code> <em>instantiates</em> the
<code>screenManager</code> class as an object called <code>s</code>.
</dd>
<dt>Method</dt>
<dd>
The name given by MATLAB to a function contined in a class.
</dd>
</dl>
<!--
digraph{
    prefix[label="prefix\nhide(stims)"];
    fixate[label="fixate\nshow(stims,2)"];
    stimulus[label="stimulus\nshow(stims,[1 2])"];
    prefix -> fixate;
    fixate -> stimulus[label="inFixFcn:\nstimulus"];
    fixate -> incorrect[label="inFixFcn:\nincorrect"];
    stimulus -> correct[label="maintainFixFcn:\ncorrect"];
    stimulus -> breakfix[label="maintainFixFcn:\nbreakfix"];;
    correct -> prefix [label="rewarded"];
    breakfix -> timeout;
    incorrect -> timeout;
    timeout -> prefix;
} -->
</body>
</html>
